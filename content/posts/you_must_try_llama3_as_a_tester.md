---
title: "ç ´é˜²äº†ï¼Œæˆ‘ç”¨æœ¬åœ°è¿è¡Œçš„aiå†™ä»£ç ï¼Œæ„Ÿè§‰å®ƒæ¯”æˆ‘å‰å®³å¤šäº†"
date: 2024-04-25T22:14:17+08:00
draft: false
---

äº‹æƒ…æ˜¯è¿™æ ·çš„ï¼Œå‰å‡ å¤© facebook å‘å¸ƒäº†æœ€æ–°çš„[llama3 æ¨¡å‹](https://ai.meta.com/blog/meta-llama-3/)ï¼Œæˆ‘ç¬¬ä¸€æ—¶é—´å°±ç”¨[ollama](https://ollama.com/library/llama3)ä¸‹è½½è¿è¡Œäº†ä¸€ä¸‹ï¼Œ8b æ¨¡å‹çš„ size å¾ˆå°ï¼Œåªæœ‰ 4.6G çš„æ ·å­ï¼Œåœ¨æˆ‘ 16g æ˜¾å­˜çš„å°å¼æœºä¸Šï¼Œé€Ÿåº¦ç›¸å½“å¿«ï¼Œå¿«åˆ°æœ‰ç‚¹ææƒšï¼Œç°åœ¨çš„æœ¬åœ°æ¨¡å‹è¿™ä¹ˆå¼ºäº†å—ï¼Ÿ

æœ¬ç€åˆ¤æ–­æœ¬åœ°æ¨¡å‹å”¯ä¸€çš„æ ‡å‡†å°±æ˜¯è®©å®ƒåšä¸­è‹±æ–‡ç¿»è¯‘çš„åŸåˆ™ï¼Œæˆ‘è®© llama3 ç¿»è¯‘äº†å‡ ä¸ªè‹±æ–‡å¥å­ï¼Œä¸æ„å¤–ï¼ŒåŸºæœ¬è¨€ä¸è¾¾æ„ï¼Œå®Œå…¨ä¸å¯ç”¨ï¼Œç„¶åå°±ç®€å•äº†ï¼Œç»™å®ƒè´´ä¸Šä¸å¯ç”¨çš„æ ‡ç­¾ï¼Œå°±åœ¨æˆ‘çš„æ¨¡å‹åº“é‡Œå¾…ç€å¥½äº†ã€‚

ç„¶è€Œå‡ å¤©åäº‹æƒ…æ¥äº†ä¸ª 180 åº¦å¤§åè½¬ï¼Œæˆ‘å‘ç°å¤§å®¶çš„æµ‹è¯•ç»“æœéƒ½éå¸¸çš„æ­£å‘ï¼Œç›´å‘¼è¿™åº”è¯¥æ˜¯ç›®å‰ä¸ºæ­¢æœ€å¼ºçš„æœ¬åœ°è¿è¡Œå¤§æ¨¡å‹äº†ï¼Œæœ‰äººæµ‹è¯•äº† 70b çš„ç‰ˆæœ¬ï¼Œç”šè‡³æŠŠè¿™ä¸ªç‰ˆæœ¬è·Ÿ gpt4 ç›¸æå¹¶è®ºã€‚

è¿™ä¸ç§‘å­¦å‘€ï¼Œæ˜æ˜è¿™ç©æ„è¿è‹±è¯‘ä¸­éƒ½æä¸å¥½ï¼Œæ€ä¹ˆå¯èƒ½è¯„ä»·è¿™ä¹ˆé«˜å‘¢ï¼Ÿ

æœ¬ç€è¯•è¯•ä¸è¦é’±çš„æ€åº¦ï¼Œæˆ‘éšä¾¿é—®äº†å®ƒå‡ ä¸ªè·Ÿè‡ªåŠ¨åŒ–ç›¸å…³çš„é—®é¢˜ï¼Œç»“æœç¡®å®è®©äººæƒŠè®¶ã€‚

é¦–å…ˆ llama3 åº”è¯¥ 95%çš„è®­ç»ƒææ–™éƒ½æ˜¯è‹±æ–‡çš„( over 5% of the Llama 3 pretraining dataset consists of high-quality non-English data that covers over 30 languages)ï¼Œæ‰€ä»¥ä¸­æ–‡ä¸å¥½æ— å¯åšéï¼Œè·Ÿå…¶äº¤äº’çš„æ—¶å€™æœ€å¥½ç”¨è‹±æ–‡æé—®ã€‚äºæ˜¯æˆ‘ç”¨è¹©è„šçš„è‹±æ–‡é—®äº†å®ƒç¬¬ä¸€ä¸ªé—®é¢˜ã€‚

### ç¬¬ä¸€ä¸ªé—®é¢˜

Open a browser using selenium and go to www.itest.info, then write a pytest assert to verify the page title should equal to é‡å®šå‘ç§‘æŠ€, please give me the entile python code

ç¿»è¯‘è¿‡æ¥å°±æ˜¯`æ‰“å¼€æµè§ˆå™¨ï¼Œè®¿é—®itest.info,ç„¶åç”¨pytestå†™ä¸ªæ–­è¨€ï¼Œå†…å®¹æ˜¯æµè§ˆå™¨çš„titleåº”è¯¥ç­‰äºé‡å®šå‘ç§‘æŠ€ï¼Œç›´æ¥ç»™æˆ‘pythonä»£ç `

ä¸‹é¢æ˜¯ llama3 ç§’å›çš„ç»“æœï¼ŒçœŸçš„æ˜¯ç§’å›ï¼ŒåŸºæœ¬ä¸Šåˆšæ•²å®Œå›è½¦å°±å¼€å§‹ç‚«äº† ğŸ˜‚ã€‚

Here is the Python code that uses Selenium WebDriver with Pytest to open a browser, navigate to `www.itest.info`, and assert that the page title equals "é‡å®šå‘ç§‘æŠ€":

```python
import pytest
from selenium import webdriver

@pytest.fixture
def browser():
    driver = webdriver.Chrome()  # Replace with your preferred browser
    yield driver
    driver.quit()

def test_itest_info(browser):
    browser.get("https://www.itest.info")
    assert browser.title == "é‡å®šå‘ç§‘æŠ€"
```

Let me explain what each line does:

1. `import pytest`: We're using Pytest for our testing framework.
2. `from selenium import webdriver`: We're importing the Selenium WebDriver library.
3. `@pytest.fixture`: This is a Pytest fixture, which sets up and tears down resources (in this case, a browser instance) for each test.
4. `def browser():`: The fixture function returns a browser object, which we'll use to interact with the website.
5. `driver = webdriver.Chrome()`: We're creating a new Chrome browser instance (replace with your preferred browser if needed).
6. `yield driver`: This is where the browser instance is yielded back to the test function.
7. `browser.quit()`: After the test is finished, we'll close the browser instance using the `quit()` method.
8. `def test_itest_info(browser):`: Our actual test function takes a browser instance as an argument.
9. `browser.get("https://www.itest.info")`: We're navigating to the website using the `get()` method.
10. `assert browser.title == "é‡å®šå‘ç§‘æŠ€"`: We're asserting that the page title is equal to "é‡å®šå‘ç§‘æŠ€". If this assertion fails, Pytest will raise an exception.

To run this code, save it in a file (e.g., `itest_test.py`) and then run it using Pytest:

```
$ pytest itest_test.py
```

This should execute the test and report any failures or errors.

æ€ä¹ˆè¯´å‘¢ï¼Œä¸ä»…å†™çš„æ¯”æˆ‘å¿«ï¼Œè€Œä¸”å†™çš„è¿˜æ¯”æˆ‘å¥½ï¼Œä¸ä»…å†™çš„æ¯”æˆ‘å¥½ï¼Œè¿˜è§£é‡Šäº†ä¸€å¤§å †ï¼Œéƒ½è¯´è¨€å¤šå¿…å¤±ï¼Œä¸è¿‡å®ƒçš„è§£é‡Šä¼¼ä¹æ²¡å•¥é—®é¢˜ã€‚

### ç¬¬äºŒä¸ªé—®é¢˜

then click a button with id = 12345

æ¥ä¸‹æ¥ç‚¹å‡»ä¸€ä¸ª id ä¸º 12345 çš„ button

ä¾ç„¶ç§’å›ï¼Œç°åœ¨çš„å¤§æ¨¡å‹ï¼Œæ€§å­éƒ½é‚£ä¹ˆæ€¥ã€‚

Here is the updated code that clicks a button with an ID of `12345` after navigating to the website:

```python
import pytest
from selenium import webdriver

@pytest.fixture
def browser():
    driver = webdriver.Chrome()  # Replace with your preferred browser
    yield driver
    driver.quit()

def test_itest_info(browser):
    browser.get("https://www.itest.info")

    # Find and click the button with ID 12345
    button = browser.find_element_by_id("12345")
    button.click()

    assert browser.title == "é‡å®šå‘ç§‘æŠ€"
```

Here's what's new:

1. We use `browser.find_element_by_id()` to locate an element (in this case, a button) with the specified ID (`12345`).
2. We store the found element in the `button` variable.
3. We call the `click()` method on the button to simulate clicking it.

Note that if there are multiple elements on the page with the same ID, Selenium will throw an exception when trying to find the element. To avoid this, you can use more specific locator strategies (e.g., CSS selectors or XPath expressions) or ensure that the ID is unique on the page.

ç»ˆäºå‡ºé—®é¢˜äº†ï¼Œ`find_element_by_id`æ˜¯è€çš„æ¥å£ï¼Œè¿™æ ·å†™å‡ å¹´å‰æ²¡é—®é¢˜ï¼Œä½†ç°åœ¨å°±ä¸è¡Œäº†ï¼Œç›®å‰æ¯”è¾ƒé€šç”¨çš„å†™æ³•æ˜¯ä½¿ç”¨`By.ID`è¿™ç§å½¢å¼ã€‚

### ç¬¬ä¸‰ä¸ªé—®é¢˜

The code above is not correct, please use By.ID to refactor it.

ä¸Šé¢çš„ä»£ç ä¸å¯¹ï¼Œè¯·ä½¿ç”¨ By.ID æ¥è¿›è¡Œé‡æ„ã€‚

å—¯ï¼Œè¿˜æ˜¯ç§’å›ï¼Œè¿™å›ä¹ æƒ¯äº†ã€‚

I apologize for the mistake! Here is the corrected code:

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By

@pytest.fixture
def browser():
    driver = webdriver.Chrome()  # Replace with your preferred browser
    yield driver
    driver.quit()

def test_itest_info(browser):
    browser.get("https://www.itest.info")

     # Find and click the button with ID 12345 using By.ID
    button = browser.find_element(by=By.ID, value="12345")
    button.click()

    assert browser.title == "é‡å®šå‘ç§‘æŠ€"
```

I've refactored the code to use the `By` class from Selenium's `webdriver.common.by` module, which provides a more explicit way of specifying the locator strategy. In this case, we're using `By.ID` to locate the element by its ID.

Note that I also replaced `find_element_by_id()` with `find_element(by=By.ID, value="12345")`, which is the recommended way to use the new locator strategy.

llama3 ä¸ä»…é“æ­‰äº†ï¼Œè¿˜æ”¹æ­£äº†ç»“æœã€‚å¦‚æœè¿™æ˜¯ chatgpt3.5 æˆ–è€… claude3ï¼Œè¿™å°±æ˜¯åŸºæœ¬æ“ä½œï¼Œæ²¡å•¥å¤§ä¸äº†çš„ï¼Œä½†å¯¹äºä¸€ä¸ªæœ¬åœ°è¿è¡Œçš„æ¨¡å‹æ¥è¯´ï¼Œè¿™ç§è¡¨ç°å®åœ¨æ˜¯éå¸¸å¯ä»¥äº†ã€‚

### æœ‰åˆæ­¥ç»“è®ºäº†

çœ‹æ¥ llama3 åœ¨è§£å†³ç¼–ç¨‹é—®é¢˜ä¸Šæ˜¯å±äº**å¯ç”¨**çš„çŠ¶æ€ã€‚

- å¯¹äºä¸€èˆ¬çš„å¼€å‘äººå‘˜æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥ä»é¢ç›¸ google çš„ç¼–ç¨‹æ…¢æ…¢è½¬å˜ä¸ºéƒ¨åˆ†é¢ç›¸æœ¬åœ° llm çš„ç¼–ç¨‹æ¨¡å¼äº†ã€‚
- å¯¹äºä¼ä¸šæ¥è¯´ï¼Œæœ¬åœ°çš„ llm ä¸å­˜åœ¨æŠŠä»£ç ä¼ åˆ°è¿œç¨‹çš„é—®é¢˜ï¼Œä¿¡æ¯å®‰å…¨æ€§çš„é—®é¢˜å¯ä»¥éƒ¨åˆ†è§£å†³äº†ã€‚
- å¯¹äºæµ‹è¯•äººå‘˜æ¥è¯´ï¼Œä¼šä¸€äº›åŸºæœ¬çš„ç¼–ç¨‹æŠ€å·§å°±å¯ä»¥å®ç°ä½¿ç”¨è‡ªç„¶è¯­è¨€è¿›è¡Œæµ‹è¯•ç”¨ä¾‹ç¼–å†™çš„èƒ½åŠ›äº†ã€‚è¿™æ˜¯ä¹‹å‰å¾ˆå¤šå¹´å¤§å®¶è¿½æ±‚çš„ç›®æ ‡ï¼Œç°åœ¨ä¸€ä¸ªæœ¬åœ° 4.6g çš„æ¨¡å‹åŸºæœ¬å¯ä»¥è®©æˆ‘ä»¬æ‘¸åˆ°ä¸€ç‚¹ç‚¹è¾¹äº†ï¼›
- å¯¹äºè´¨é‡ç®¡ç†æ¥è¯´ï¼Œç”¨æœ¬åœ° llm è·Ÿå¼€å‘äººå‘˜è¿›è¡Œç»“å¯¹ç¼–ç¨‹ä¼¼ä¹ä¹Ÿæœ‰äº†å¯èƒ½æ€§ï¼Œå¼€å‘äººå‘˜å†™ä»£ç ï¼Œllm ç”Ÿæˆå•å…ƒæµ‹è¯•ä»£ç ï¼Œä¹Ÿè®¸åªè¦é€šè¿‡å¾®è°ƒå°±å¯ä»¥éƒ¨åˆ†å®ç°ï¼›

### è¯•ä¸€è¯•ç¨å¾®éš¾ä¸€ç‚¹çš„é—®é¢˜

using go access this api https://api.dictionaryapi.dev/api/v2/entries/en/<word>, then print the all the meannings from the response, the respinse is a json string, it is like `[
    {
      "word": "hello",
      "phonetic": "hÉ™ËˆlÉ™ÊŠ",
      "phonetics": [
        {
          "text": "hÉ™ËˆlÉ™ÊŠ",
          "audio": "//ssl.gstatic.com/dictionary/static/sounds/20200429/hello--_gb_1.mp3"
        },
        {
          "text": "hÉ›ËˆlÉ™ÊŠ"
        }
      ],
      "origin": "early 19th century: variant of earlier hollo ; related to holla.",
      "meanings": [
        {
          "partOfSpeech": "exclamation",
          "definitions": [
            {
              "definition": "used as a greeting or to begin a phone conversation.",
              "example": "hello there, Katie!",
              "synonyms": [],
              "antonyms": []
            }
          ]
        },
        {
          "partOfSpeech": "noun",
          "definitions": [
            {
              "definition": "an utterance of â€˜helloâ€™; a greeting.",
              "example": "she was getting polite nods and hellos from people",
              "synonyms": [],
              "antonyms": []
            }
          ]
        },
        {
          "partOfSpeech": "verb",
          "definitions": [
            {
              "definition": "say or shout â€˜helloâ€™.",
              "example": "I pressed the phone button and helloed",
              "synonyms": [],
              "antonyms": []
            }
          ]
        }
      ]
    }
  ]`

ç”¨ golang å»è®¿é—® 1 ä¸ª apiï¼Œç„¶åæ‰“å°è¿”å›å€¼é‡Œçš„ meanings å­—æ®µï¼Œè¿™é‡Œ meannings å­—æ®µæ¯”è¾ƒå¤æ‚ï¼Œå¤„ç†èµ·æ¥æœ‰ç‚¹ç‚¹éº»çƒ¦ã€‚

è¿™æ—¶å€™ llama3 çš„å›ç­”å°±æœ‰æ„æ€äº†ã€‚

Here is a sample Go program that sends an HTTP request to the API, parses the JSON response, and prints out all the meanings:

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io/ioutil"
    "net/http"
)

func main() {
    // Set the word you want to look up
    word := "hello"

    // Make an HTTP request to the API
    url := fmt.Sprintf("https://api.dictionaryapi.dev/api/v2/entries/en/%s", word)
    resp, err := http.Get(url)
    if err != nil {
        panic(err)
    }
    defer resp.Body.Close()

    // Read the response body
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        panic(err)
    }

    // Unmarshal the JSON response
    var data []map[string]interface{}
    err = json.Unmarshal(body, &data)
    if err != nil {
        panic(err)
    }

    // Print out all the meanings
    for _, entry := range data {
        for _, meaning := range entry["meanings"].([]interface{}) {
            fmt.Println("Part of speech:", (meaning.(map[string]interface{}))["partOfSpeech"])
            for _, definition := range (meaning.(map[string]interface{}))["definitions"].([]interface{}) {
                fmt.Println("Definition:", definition.(map[string]interface{})["definition"])
                if example, ok := definition.(map[string]interface{})["example"]; ok {
                    fmt.Println("Example:", example)
                }
                if synonyms, ok := definition.(map[string]interface{})["synonyms"]; ok && len(synonyms.([]interface{})) > 0 {
                    fmt.Println("Synonyms:", synonyms)
                }
            }
        }
    }
}
```

This program sends an HTTP GET request to the API with the specified word, reads the response body, and then unmarshals it into a slice of maps. It then iterates over this slice and prints out all the meanings.

Please note that you should handle the error cases more robustly in production code. This is just a sample program.

æˆ‘æ²¡è¿è¡Œä»£ç ï¼Œä¸è¿‡çœ‹ä¸Šå»å¯èƒ½æ˜¯è·‘å¾—èµ·æ¥çš„ã€‚ä¸è¿‡å¾ˆæ˜¾ç„¶è¿™ç§å®ç°æ–¹å¼ä¸æ˜¯å¾ˆå¦™å‘€ã€‚

ç»§ç»­è®©å®ƒç”¨ struct æ¥é‡æ„ã€‚

refactor the above code, use a struct to parse the json string

è¿™æ—¶å€™ llama3 åº”è¯¥æ˜¯æ··ä¹±äº†ã€‚

Here's how you can refactor the above code using structs:

```go
package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
)

type Meaning struct {
	PartOfSpeech string   `json:"partOfSpeech"`
_DEFINITIONS  []Definition `json:"definitions"`
}

type Definition struct {
	Definition    string `json:"definition"`
	Example       string `json:"example,omitempty"`
	Synonyms      []string `json:"synonyms,omitempty"`
	Antonyms      []string `json:"antonyms,omitempty"`
}

func main() {
	word := "hello"

	url := fmt.Sprintf("https://api.dictionaryapi.dev/api/v2/entries/en/%s", word)
	resp, err := http.Get(url)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	var data []Entry
	err = json.Unmarshal(body, &data)
	if err != nil {
		panic(err)
	}

	for _, entry := range data {
		fmt.Println("Word:", entry.Word)
		for _, meaning := range entry.Meanings {
			fmt.Println("Part of speech:", meaning.PartOfSpeech)
			for _, definition := range meaning._DEFINITIONS {
				fmt.Println("Definition:", definition.Definition)
				if definition.Example != "" {
					fmt.Println("Example:", definition.Example)
				}
				if len(definition.Synonyms) > 0 {
					fmt.Println("Synonyms:", definition.Synonyms)
				}
				if len(definition.Antonyms) > 0 {
					fmt.println("Antonyms:", definition.Antonyms)
				}
			}
		}
	}
}

type Entry struct {
	Word       string     `json:"word"`
	Pronunciation string    `json:"phonetic"`
	Pronunciations []Pronunciation `json:"phonetics"`
	Origin      string     `json:"origin"`
	Meanings    []Meaning  `json:"meanings"`
}

type Pronunciation struct {
	Text  string `json:"text"`
	Audio string `json:"audio"`
}
```

In this code, I've defined three structs: `Meaning`, `Definition`, and `Entry`. The `Meaning` struct has a part of speech and a slice of definitions. The `Definition` struct has a definition, example, synonyms, and antonyms. The `Entry` struct has a word, pronunciation, origin, and meanings.

I then used these structs to unmarshal the JSON response from the API. This makes the code more readable and easier to maintain, as it separates the logic of parsing the JSON into its constituent parts from the logic of printing out the results.

æ„æ€å¯¹äº†ï¼Œä½†æ˜¯ä»£ç ä¸å¤Ÿå‡†ç¡®ï¼Œç¨å¾®å¤æ‚ä¸€ç‚¹çš„ä»£ç ï¼Œllama3 å¤„ç†èµ·æ¥è¿˜æ˜¯æœ‰éš¾åº¦çš„ã€‚

### ç»“è®º

æµ‹è¯•äººå‘˜ç¦éŸ³ï¼Œå¾ˆå¤šå…¬å¸è®¿é—®ä¸äº† chatgpt ç­‰å›½å¤–çš„ ai ç«™ç‚¹ï¼Œç”¨è¿™ä¸ªæœ¬åœ°å†™å†™ç®€å•çš„æµ‹è¯•ç”¨ä¾‹è¿˜æ˜¯æœ‰æå¤´çš„ï¼Œå¾ˆå¤šæµ‹è¯•åŒå­¦çš„ä»£ç èƒ½åŠ›å…¶å®å¹¶ä¸å¼ºï¼Œå¯ä»¥ç”¨æœ¬åœ° llm æ¥å¸®å¿™æ£€æŸ¥ä»£ç æˆ–è€…ç”Ÿæˆéƒ¨åˆ†ä»£ç ï¼Œåº”è¯¥èƒ½èŠ‚çº¦ä¸å°‘æ—¶é—´ã€‚

### æœ¬æ–‡ç”¨åˆ°çš„å·¥å…·

- ollama
- [openwebui](https://openwebui.com/)
- Raycast llama3 æ’ä»¶
- vscode continue æ’ä»¶

### å½©è›‹

è¿™æ˜¯æˆ‘ä¸å°å¿ƒå‘ç°çš„ 1 ä¸ªè½¯ä»¶æµ‹è¯•çš„ system promptï¼Œæœ‰å…´è¶£çš„åŒå­¦å¯ä»¥è¯•è¯•ã€‚

```
SYSTEM """
As a certified Software Testing expert, I am equipped to provide comprehensive assistance in Software Testing using official ISTQB terminology and methodologies. My expertise encompasses roles such as Test Analyst, Technical Test Analyst and Test Manager. I offer training and education in Software Testing, providing in-depth knowledge and practical insights.

As specialist, I interactively assist organizations in implementing robust test processes, concepts and strategies step by step. Additionally, I support individuals in their day-to-day software testing tasks, carrying out work steps, offering expert advice and solutions tailored to specific software testing challenges. For example, clients may provide test cases, requirements documentation and bug reports to aid in the testing process. To streamline my assistance, I recommend that clients upload relevant work items using Open WebUI with document upload support <https://docs.openwebui.com>. Alternatively, text input can be provided when Open WebUI is not available.

For adherence to ISTQB standards, clients are encouraged to use Open WebUI together with glossary, syllabus, and text exam documents uploaded from <https://www.istqb.org/certifications/>. This will ensure that my assistance is aligned with the latest industry best practices and standards. Together, we can achieve exceptional results in Software Testing.
"""

```
